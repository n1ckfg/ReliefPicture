<!DOCTYPE html>
<html lang="en">

	<head>
	    <meta charset="utf-8">
		<title>ReliefPicture</title>
    	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    	<!--<meta property="og:image" content="thumbnail.gif">-->
		<link rel="stylesheet" href="./css/style.css">
		<script src="./js/libraries/p5.min.js"></script>
		<script src="./js/libraries/p5.HeightToNormal.js"></script>
		<script src="./js/libraries/Tone.js"></script>
		<script src="./js/libraries/socket.io.js"></script>
	</head>

	<body>
		<script>
			"use strict";

		    let pg, matte, imgCrop; // PGraphics
			let img, normalMap; // PImage
		    let h2n; // HeightToNormal
			let sW = 800;
			let sH = 800;
			let m, pm, offset;
			let dist = 0;

			// https://tonejs.github.io/docs/r13/Noise
			let audioAuthorized = false;
			let noise, autoFilter;

			document.addEventListener("mousedown", function() {
				if (!audioAuthorized) {
					Tone.start();

					//initialize the noise and start
					noise = new Tone.Noise("pink").start();

					//make an autofilter to shape the noise
					autoFilter = new Tone.AutoFilter({
						"frequency" : "8m",
						"min" : 800,
						"max" : 15000
					}).connect(Tone.Master);
					
					noise.connect(autoFilter); // connect the noise
					autoFilter.start(); // start the autofilter LFO

					audioAuthorized = true;
				}
			});

			const socket = io();

			socket.on("newImage", function(data) {
				console.log("Received new data.");
			});

			function preload() {
				img = loadImage("./images/fish.jpg");
			}

		    function setup() {
			    createCanvas(windowHeight, windowHeight);
		        background(0);
		        pixelDensity(1);
		        
		        offset = createVector(0, 0);
		        m = createVector(0, 0);
		        pm = createVector(0, 0);

		        if (img.width > img.height) {
		        	let ratio = img.width / img.height;
		        	img.resize(sW * ratio, sW);
		        	offset.x = (img.width - img.height) / -2;
		        } else if (img.height > img.width) {
		        	let ratio = img.height / img.width;
		        	img.resize(sH, sH * ratio);
		        	offset.y = (img.height - img.width) / -2;
		        }

		        imgCrop = createGraphics(sW, sH);
		        imgCrop.push();
		        imgCrop.image(img, offset.x, offset.y);
		        imgCrop.pop();

		        pg = createGraphics(sW, sH, WEBGL);

		        matte = createGraphics(sW, sH);
		        matte.push();
		        matte.background(0);
		        matte.pop();

		        h2n = new HeightToNormal(sW, sH);
		        /*
		            last two arguments are optional
		            strength -  Strength of the normal. Values closer 
		                        to 0 will make z component of vectors
		                        have more influence pointing 'outwards'.
		                        Typical values: 0.001 - 10
		                        Default value is 2.

		            level - Typical values: 5 - 7.
		                    Larger values will make the z component of the normal 
		                    vector have a stronger influence.
		                    Default value is 7.
		        */
		        normalMap = h2n.get(imgCrop, 2, 7);
		    }

		    function getMouseAxis(isX, isWebGl) {
		    	let returns;

		    	if (isX) {
		    		returns = sW * (mouseX / width);
		    		if (isWebGl)  returns -= (sW / 2);
		    	} else {
		    		returns = sH * (mouseY / height);
		    		if (isWebGl)  returns -= (sH / 2);
		    	}

		    	return returns;
		    }

		    function draw() {
		    	if (mouseIsPressed) {
		    		pm.x = m.x;
		    		pm.y = m.y;
			    	m.x = getMouseAxis(true, false);
			    	m.y = getMouseAxis(false, false);

			    	matte.push();
		    		matte.blendMode(BLEND);
			        matte.noStroke();
			        matte.fill(255, 64);
			        
			        dist = constrain(m.dist(pm), 10, 80) * 10;
			        if (audioAuthorized) {
			        	let distForVolume = constrain(dist, 0, 500);
			        	let newVolume = map(distForVolume, 0, 500, -10, 2);
			        	noise.volume.value = newVolume;
			        	
			        	noise._playbackRate = dist / 500;
			        	autoFilter.min = dist;
			        	autoFilter.max = dist * 20;
			        	console.log(noise.volume.value + ", " + dist);
			        }

			        matte.ellipse(m.x, m.y, dist);
			        matte.ellipse(m.x, m.y, dist - 20);
			        matte.ellipse(m.x, m.y, dist - 40);
			        matte.ellipse(m.x, m.y, dist - 60);

					matte.blendMode(MULTIPLY);			        
					matte.image(normalMap, 0, 0);
			        matte.filter(GRAY);
			        matte.pop();
		    	}

		        pg.push();
		        pg.blendMode(BLEND);
		        pg.image(imgCrop, -pg.width/2, -pg.height/2, pg.width, pg.height);
		        pg.blendMode(MULTIPLY);
		        pg.image(matte, -pg.width/2, -pg.height/2, pg.width, pg.height);
		        pg.pop();

		        blendMode(BLEND);
		        image(pg, 0, 0, width, height);

		        blendMode(ADD);
		        image(pg, 0, 0, width, height);
		    }

			function windowResized() {
				resizeCanvas(windowHeight, windowHeight);
			}

			let query = "";
			let responseImg;

			function queryImage(_q) {
			  const url = "https://ajax.googleapis.com/ajax/services/search/images?v=1.0&q=" + _q;
			  console.log(url);
			  //loadJSON(url, imageResult);
			}

			function imageResult(result) {
				//make sure the results are not an error
				const status = result["responseStatus"];
				console.log(status);
				/*
				if (status != 200) {
				var reason = result.getString("responseDetails");
				//this sucks that google does not allow you to do very many of these in a row
				println("You are too fast, take a break." + reason);
				return;
				}
				//go one level down in to the results to just get the data not the info about the package
				var response = result.getJSONObject("responseData");
				println(response);
				//get the arrary of stuff you got back
				var values = response.getJSONArray("results");
				var vOffset = 20;
				for (int i = 0; i < min(values.size(),3); i++) {
				//pick out the picture information for each picture
				var thisGuy = values.getJSONObject(i); 
				var r = thisGuy.getString("url");
				var w = thisGuy.getInt("tbWidth");
				var h = thisGuy.getInt("tbHeight");
				println(r + " "+ w + " " + h );
				var thisImage = loadImage(r);
				if (thisImage != null) {
				image(thisImage, 10, vOffset, w, h);
				}
				else {
				text((i + 1) + " key", 10, vOffset+13);
				rect(10, vOffset, w, h);
				}
				//make vOffset bigger so we will draw the next picture below this one.
				vOffset  += h;

				}//end for
				*/
			}

			function keyPressed() {
				if (keyCode === RETURN || keyCode === ENTER) {
					background(0);
					queryImage(query); // execute the query
					query = "";  // clear the query
				} else if (keyCode > 48 && keyCode < 123) {  // letters and numbers only
					query += key;
					fill(255);
					text(query, 100, 100);  // draw the query so far on the scrren
				}
			}
		</script>
	</body>

</html>